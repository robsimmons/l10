(* L10 grammar, by Rob Simmons *)

structure A = Ast
open Symbol

datatype decl = 
   DeclClass of Symbol.symbol
 | DeclDef of Symbol.symbol
 | DeclDependency of Symbol.symbol * Symbol.symbol
 | DeclRule

datatype syn = 
   Ascribe of string * syn
 | Assign of string * syn
 | Conj of syn * syn
 | Arrow of syn * syn
 | At of syn * syn
 | Pi of syn * syn
 | Ex of string * syn
 | Var of string option
 | App of string * syn list
 | Int of int
 | Str of string
 | World
 | Type 
 | Rel
 | Binrel of A.binrel * syn * syn

fun string syn =
   case syn of  
      Ascribe (c, s) => c ^ " : " ^ string s 
    | Assign (c, s) => c ^ " = " ^ string s
    | Conj (s1, s2) => "(" ^ string s1 ^ ", " ^ string s2 ^ ")"
    | Arrow (s1, s2) => "(" ^ string s1 ^ " -> " ^ string s2 ^ ")"
    | At (s1, s2) => "(" ^ string s1 ^ " @ " ^ string s2 ^ ")"
    | Pi (s1, s2) => "({" ^ string s1 ^ "} " ^ string s2 ^ ")"
    | Ex (s1, s2) => "(Ex " ^ s1 ^ ". " ^ string s2 ^ ")"
    | Var (SOME s) => s
    | Var NONE => "_"
    | App (c, s) => "(" ^ c ^ " ^ " ^ String.concatWith " " (map string s) ^ ")"
    | Int i => Int.toString i
    | Str s => "\"" ^ s ^ "\""
    | World => "world"
    | Type => "type"
    | Rel => "rel"
    | Binrel (br, s1, s2) => 
      "(" ^ string s1 ^ " " ^ A.strBinrel br ^ " " ^ string s2 ^ ")"

exception Internal
exception SyntaxError of string

val worlds = ref Set.empty (* map of the worlds *)

fun cons (arg, decl) =
   case decl of 
      A.DeclConst (id, args, typ) => A.DeclConst (id, arg :: args, typ)
    | A.DeclRelation (id, args, w) => A.DeclRelation (id, arg :: args, w) 
    | A.DeclWorld (id, args) => A.DeclWorld (id, arg :: args)
    | _ => raise Internal




fun p_term syn = 
   case syn of 
      App (c, []) => A.Const (symbol c)
    | App (c, syns) => A.Structured (symbol c, map p_term syns)
    | Int i => A.NatConst (IntInf.fromInt i)
    | Str s => A.StrConst s
    | Var x => A.Var (Option.map symbol x)
    | _ => raise SyntaxError "Invalid term"




fun p_typ syn = 
   case syn of 
      App (typ, []) => symbol typ
    | _ => raise SyntaxError "Invalid simple type"      

fun p_atomic syn = 
   case syn of 
      App (a, terms) => (symbol a, map p_term terms)
    | _ => raise SyntaxError "Invalid atomic proposition"

fun p_atomics syn = 
   case syn of 
      Conj (syn1, syn2) => p_atomics syn1 @ p_atomics syn2
    | _ => [ p_atomic syn ]

fun p_pat syn =
   case syn of 
      Ex (x, syn) => A.Exists (symbol x, p_pat syn)
    | Conj (syn1, syn2) => A.Conj (p_pat syn1, p_pat syn2)
    | _ => A.Atomic (p_atomic syn)

fun p_prem syn = 
   case syn of 
      App ("not", [ syn ]) => A.Negated (p_pat syn)
    | App ("count", [ syn1 , syn2 ]) => A.Count (p_pat syn1, p_term syn2)
    | Binrel (br, syn1, syn2) => A.Binrel (br, p_term syn1, p_term syn2)
    | _ => A.Normal (p_pat syn)

fun p_prems syn = 
   case syn of 
      Conj (syn1, syn2) => p_prems syn1 @ p_prems syn2
    | _ => [ p_prem syn ]

fun p_rule syn =
   case syn of 
      Arrow (prems, head) => (p_prems prems, p_atomics head)
    | _ => ([], p_atomics syn)



fun p_class (id, syn) = 
   case syn of 
      Arrow (typ, s) => cons ((NONE, p_typ typ), p_class (id, s))
    | Pi (Ascribe (x, typ), s) => 
      cons ((SOME (symbol x), p_typ typ), p_class (id, s))
    | App (typ, []) => A.DeclConst (id, [], symbol typ)
    | World => 
      (worlds := Set.add (!worlds, id); A.DeclWorld (id, []))
    | At (Rel, syn) => A.DeclRelation (id, [], p_atomic syn)
    | At (syn, _) => 
      raise SyntaxError 
      ("Nothing can be left of an @ symbol, found " ^ string syn)   
    | _ => raise SyntaxError ("Bad classifier")

fun p_worldhead (App (x, syns)) =
   let val x = symbol x in
      if (Set.member (!worlds, x)) 
      then SOME (x, map p_term syns)
      else NONE
   end
  | p_worldhead _ = NONE

fun parse syn = 
   case syn of 
      Ascribe (id, Type) => A.DeclType (symbol id)
    | Ascribe (id, syn) => p_class (symbol id, syn)
    | Assign (id, At (syn, w)) => 
      let (* val () = print ("---\n" ^ string w ^ "---\n")  *) in
         A.DeclDatabase (symbol id, p_atomics syn, p_atomic w)
      end
    | Arrow (prems, head) =>
      (case p_worldhead head of 
          NONE => A.DeclRule (p_rule syn)
        | SOME w => A.DeclDepends(w, p_atomics prems))
    | _ => raise SyntaxError ("Invalid toplevel statement")

%%
%name L10

%nonterm 
   anno of syn
 | decl of (A.decl * unit * unit)
 | syn of syn
 | simp of syn
 | sings of syn list

%term 
   EOF | LPAREN | RPAREN | LCURLY | RCURLY | EXISTS 
 | PERIOD | COMMA | COLON | EQUALS | LARROW | RARROW | AT
 | EQEQ | NEQ | GT | LT | GEQ | LEQ | PLUS
 | WORLD | TYPE | REL | UNDERSCORE
 | UCID of string | LCID of string | INTCONST of int | STRCONST of string

%pos unit     (* positions *)

%header (functor L10LrValsFn (structure Token : TOKEN))

%verbose        (* print summary of errors *)
%start decl     (* parse one declaration at a time *)
%eop EOF PERIOD (* possible start symbols for next declaration *)
%noshift EOF    (* possible start symbols for next declaration *)

%nonassoc EQUALS COLON
%left  LARROW
%right RARROW
%right COMMA
%nonassoc AT
%nonassoc NEQ EQEQ LEQ GEQ LT GT
%left PLUS

%%

decl : syn                        ((parse syn, synleft, synright))

anno  : UCID COLON syn            (Ascribe (UCID, syn))

syn   : LCID COLON syn            (Ascribe (LCID, syn))      
      | LCID EQUALS syn           (Assign (LCID, syn))      
      | syn COMMA syn             (Conj (syn1, syn2))
      | syn RARROW syn            (Arrow (syn1, syn2))
      | syn LARROW syn            (Arrow (syn2, syn1))
      | syn AT syn                (At (syn1, syn2))
      | LCURLY anno RCURLY syn    (Pi (anno, syn))
      | EXISTS UCID PERIOD syn    (Ex (UCID, syn))
      | simp                      (simp)
      | LCID sings                (App (LCID, sings)) 
      | syn EQEQ syn              (Binrel (A.Eq,  syn1, syn2))  
      | syn NEQ syn               (Binrel (A.Neq, syn1, syn2))  
      | syn GT syn                (Binrel (A.Gt,  syn1, syn2))
      | syn LT syn                (Binrel (A.Lt,  syn1, syn2))
      | syn GEQ syn               (Binrel (A.Geq, syn1, syn2))
      | syn LEQ syn               (Binrel (A.Leq, syn1, syn2))
      | syn PLUS syn              (App ("_plus", [ syn1, syn2 ]))  

simp  : LPAREN syn RPAREN         (syn) 
      | UCID                      (Var (SOME UCID))
      | UNDERSCORE                (Var NONE)
      | WORLD                     (World)
      | TYPE                      (Type)
      | REL                       (Rel) 
      | INTCONST                  (Int INTCONST)
      | STRCONST                  (Str STRCONST)

sings :                           ([])
      | simp sings                (simp :: sings)
      | LCID sings                (App (LCID, []) :: sings)

