(* L10 grammar, by Rob Simmons *)

structure A = Ast
structure Set = 
SplaySetFn(struct type ord_key = string val compare = String.compare end)

datatype decl = 
   DeclClass of string 
 | DeclDef of string
 | DeclDependency of string * string
 | DeclRule

datatype syn = 
   Ascribe of string * syn
 | Assign of string * syn
 | Conj of syn * syn
 | Arrow of syn * syn
 | At of syn * syn
 | Pi of syn * syn
 | Ex of string * syn
 | Var of string option
 | App of string * syn list
 | Int of int
 | Str of string
 | World
 | Type 
 | Rel

fun string syn =
   case syn of  
      Ascribe (c, s) => c ^ " : " ^ string s 
    | Assign (c, s) => c ^ " = " ^ string s
    | Conj (s1, s2) => "(" ^ string s1 ^ ", " ^ string s2 ^ ")"
    | Arrow (s1, s2) => "(" ^ string s1 ^ " -> " ^ string s2 ^ ")"
    | At (s1, s2) => "(" ^ string s1 ^ " @ " ^ string s2 ^ ")"
    | Pi (s1, s2) => "({" ^ string s1 ^ "} " ^ string s2 ^ ")"
    | Ex (s1, s2) => "(Ex " ^ s1 ^ ". " ^ string s2 ^ ")"
    | Var (SOME s) => s
    | Var NONE => "_"
    | App (c, s) => "(" ^ c ^ " " ^ String.concatWith " " (map string s) ^ ")"
    | Int i => Int.toString i
    | Str s => "\"" ^ s ^ "\""
    | World => "world"
    | Type => "type"
    | Rel => "rel"

exception Internal
exception SyntaxError of string

val worlds = ref Set.empty (* map of the worlds *)

fun cons (arg, decl) =
   case decl of 
      A.DeclConst (id, args, w) => A.DeclConst (id, arg :: args, w)
    | A.DeclRelation (id, args, w) => A.DeclRelation (id, arg :: args, w) 
    | A.DeclWorld (id, args) => A.DeclWorld (id, arg :: args)
    | _ => raise Internal




fun p_term syn = 
   case syn of 
      App (c, []) => A.Const c
    | App (c, syns) => A.Structured (c, map p_term syns)
    | Int i => A.IntConst i
    | Str s => A.StrConst s
    | Var x => A.Var x
    | _ => raise SyntaxError "Invalid term"




fun p_typ syn = 
   case syn of 
      App (typ, []) => typ
    | _ => raise SyntaxError "Invalid simple type"      

fun p_atomic syn = 
   case syn of 
      App (a, terms) => (a, map p_term terms)
    | _ => raise SyntaxError "Invalid atomic proposition"

fun p_world syn = 
   case syn of 
      App (w, []) => (w, NONE)
    | App (w, [ syn ]) => (w, SOME (p_term syn))
    | App _ => raise SyntaxError ("World with more than one argument")
    | _ => raise SyntaxError ("Invalid world")




fun p_pat syn =
   case syn of 
      Ex (x, syn) => A.Exists (x, p_pat syn)
    | _ => A.Atomic (p_atomic syn)

fun p_prem syn = 
   case syn of 
      App ("not", [ syn ]) => A.Negated (p_pat syn)
    | App ("count", [ syn1 , syn2 ]) => A.Count (p_pat syn1, p_term syn2)
    | _ => A.Normal (p_pat syn)

fun p_prems syn = 
   case syn of 
      Conj (syn1, syn2) => p_prems syn1 @ p_prems syn2
    | _ => [ p_prem syn ]

fun p_rule syn =
   case syn of 
      Arrow (prems, head) => (p_prems prems, p_atomic head)
    | _ => ([], p_atomic syn)




fun p_class (id, syn) = 
   case syn of 
      Arrow (typ, s) => cons ((NONE, p_typ typ), p_class (id, s))
    | Pi (Ascribe (x, typ), s) => cons ((SOME x, p_typ typ), p_class (id, s))
    | App (typ, []) => A.DeclConst (id, [], typ)
    | World => (worlds := (*Set.insert ( *)!worlds(*, id)*); A.DeclWorld (id, []))
    | At (Rel, syn) => A.DeclRelation (id, [], p_world syn)
    | At (syn, _) => 
      raise SyntaxError 
      ("Nothing can be left of an @ symbol, found " ^ string syn)   
    | _ => raise SyntaxError ("Bad classifier")

fun p_dep (App (w1, [App ("depends", []), App ("on", []), App (w2, [])])) =
    if true (* Set.inDomain (!worlds, w1) *)
    then SOME (A.DeclDepends (w1, w2)) 
    else NONE
  | p_dep _ = NONE

fun p_db syn = 
   case syn of 
      Conj (syn1, syn2) => p_db syn1 @ p_db syn2
    | _ => [ p_atomic syn ]

fun parse syn = 
   case syn of 
      Ascribe (id, Type) => A.DeclType id
    | Ascribe (id, syn) => p_class (id, syn)
    | Assign (id, At (syn, w)) => A.DeclDatabase (id, p_db syn, p_world w)
    | syn => 
      (case p_dep syn of
          SOME decl => decl
        | NONE => A.DeclRule (p_rule syn))

%%
%name L10

%nonterm 
   anno of syn
 | decl of (A.decl * unit * unit)
 | syn of syn
 | simp of syn
 | sings of syn list

%term 
   EOF | LPAREN | RPAREN | LCURLY | RCURLY | EXISTS 
 | PERIOD | COMMA | COLON | EQUALS | LARROW | RARROW | AT
 | EQEQ | NEQ | GT | LT | GEQ | LEQ | PLUS
 | WORLD | TYPE | REL | UNDERSCORE
 | UCID of string | LCID of string | INTCONST of int | STRCONST of string

%pos unit     (* positions *)

%header (functor L10LrValsFn (structure Token : TOKEN))

%verbose        (* print summary of errors *)
%start decl     (* parse one declaration at a time *)
%eop EOF PERIOD (* possible start symbols for next declaration *)
%noshift EOF    (* possible start symbols for next declaration *)

%nonassoc EQUALS COLON
%left  LARROW
%right RARROW
%right EXISTS
%right COMMA
%nonassoc AT

%%

decl : syn                        ((parse syn, synleft, synright))

anno  : UCID COLON syn            (Ascribe (UCID, syn))

syn   : LCID COLON syn            (Ascribe (LCID, syn))      
      | LCID EQUALS syn           (Assign (LCID, syn))      
      | syn COMMA syn             (Conj (syn1, syn2))
      | syn RARROW syn            (Arrow (syn1, syn2))
      | syn AT syn                (At (syn1, syn2))
      | LCURLY anno RCURLY syn    (Pi (anno, syn))
      | EXISTS UCID PERIOD syn    (Ex (UCID, syn))
      | simp                      (simp)
      | LCID sings                (App (LCID, sings)) 
      | syn EQEQ syn              (App ("_eq", [ syn1, syn2 ]))  
      | syn NEQ syn               (App ("_neq", [ syn1, syn2 ]))  
      | syn GT syn                (App ("_gt", [ syn1, syn2 ]))  
      | syn LT syn                (App ("_lt", [ syn1, syn2 ]))  
      | syn GEQ syn               (App ("_geq", [ syn1, syn2 ]))  
      | syn LEQ syn               (App ("_leq", [ syn1, syn2 ]))  
      | syn PLUS syn              (App ("_plus", [ syn1, syn2 ]))  

simp  : LPAREN syn RPAREN         (syn) 
      | UCID                      (Var (SOME UCID))
      | UNDERSCORE                (Var NONE)
      | WORLD                     (World)
      | TYPE                      (Type)
      | REL                       (Rel) 
      | INTCONST                  (Int INTCONST)
      | STRCONST                  (Str STRCONST)

sings :                           ([])
      | simp sings                (simp :: sings)
      | LCID sings                (App (LCID, []) :: sings)

