


// WORLD 2: Liveness analysis
wLive: world.
live: nat -> t -> rel @ wLive.

use L X -> live L X.

live L' U, 
succ L L', 
not (def L U) -> 
   live L U.

// WORLD 3: Interference analysis
wInter: world.
interferes: t -> t -> rel @ wInter.

def L X, 
not (Ex Y. line L (move X Y)), 
succ L L1, 
live L1 Z, 
X != Z -> 
   interferes X Z.

line L (move X Y), 
succ L L1, 
live L1 Z, 
not (eq X Z), 
not (eq Y Z) -> 
   interferes X Z.

//Neededness analysis

nec : nat -> t -> rel @ w0.

line L (if X Comp C L1) -> nec L X.
line L (return X) -> nec L X.

wNeed : world.
needed : nat -> t -> rel @ wNeed.

nec L X -> needed L X.
needed L1 U , succ L L1 , not (def L U) -> needed L U.
use L Y , def L X , succ L L1 , needed L1 X -> needed L Y.

//Deadcode analysis

wDead : world.

dead : nat -> rel @ wDead.
def L X , succ L L1 , not (needed L1 X) -> dead L.


db1 = (line 0 (loadc p 1) , line 1 (binop p p times x) , line 2 (binop z p plus 1)
           line 3 (binop x x minus 1) , line 4 (if x grt 0 2) , line 5 (return x)) @ wDead.

db2 = (line 0 (loadc p 1) , line 1 (binop p p times x) , line 2 (binop z z plus 1)
           line 3 (binop x x minus 1) , line 4 (if x grt 0 2) , line 5 (return x)) @ wLive.
