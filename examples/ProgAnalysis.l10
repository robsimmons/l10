// Commands

inst: type.
binop:  t -> t -> t -> t -> inst.
move:   t -> t -> inst.
loadc:  t -> t -> inst.
goto:   nat -> inst.
if:     t -> t -> t -> nat -> inst.
return: t -> inst.

w0: world.
line: nat -> inst -> rel @ w0.

// Extracting relevant information 

succ: nat -> nat -> rel @ w0.
def:  nat -> t -> rel @ w0.
use:  nat -> t -> rel @ w0.

line L (binop X Y Op Z) -> 
   succ L (L+1),
   def L X,
   use L Y, use L Z.

line L (move X Y) -> 
   succ L (L+1),
   def L X,
   use L Y.

line L (loadc X C) ->
   succ L (L+1),
   def L X.
   // no variables used

line L (goto L') ->
   succ L L'.
   // no variables defined
   // no variables used

line L (if X Cmp C1 L') ->
   succ L L', succ L (L+1),
   // no variables defined
   use L X.

line L (return X) ->
   // no successors
   // no variables defined
   use L X.

// Liveness analysis

wLive: world.
live: nat -> t -> rel @ wLive.

use L X -> live L X.

live L' U, 
succ L L', 
not (def L U) -> 
   live L U.

// Constructing the interference graph

wInter: world.
interferes: t -> t -> rel @ wInter.

def L X, 
not (line L (move X _)), 
succ L L', 
live L' Z, 
X != Z -> 
   interferes X Z.

line L (move X Y), 
succ L L', 
live L' Z, 
X != Z, 
Y != Z -> 
   interferes X Z.

// Necessary variables

nec: nat -> t -> rel @ w0.
line L (if X Comp C L1) -> nec L X.
line L (return X) -> nec L X.

// Neededness analysis

wNeed: world.
needed: nat -> t -> rel @ wNeed.

nec L X -> needed L X.

needed L' X, 
succ L L', 
not (def L X) ->
   needed L X.

use L Y, 
def L X, 
succ L L', 
needed L' X ->
   needed L Y.

// Dead-code analysis

wDead: world.
dead: nat -> rel @ wDead.

def L X, 
succ L L', 
not (needed L' X) -> 
   dead L.