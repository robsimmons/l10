// Backward-chaining in L10
// Robert J. Simmons

n: type.
z: n.
s: n -> n.
w: n -> n -> world.

// We can define certain "backward chaining" functions just fine in l10 under
// the static scheduling regime; all we have to do is make the inputs
// indices of the world. Keep in mind that this is a terrible idea, because
// we use discrimination trees to avoid re-visiting worlds, which makes
// our first example, bog-standard plus, quadratic (!!!)

plus: {N: n} {M: n} {P: n} rel @ w N M.
plus z N N.
plus (s N) M (s P) <- plus N M P.


// The second argument of LT must be used to index the world; otherwise
// the first rule won't be range-restricted. The first argument of LT needs
// to be indexed only for what we might call "efficiency reasons" - it means
// that static scheduling (and execution) uses only a number of stages
// proportional to the smallest of the two numbers.

lt: {N: n} {M: n} rel @ w N M.
lt z (s N).
lt (s N) (s M) <- lt N M.


// Times does not work, as an output of the first argument (plus)
// determines an input of the second argument (times)

// times: {N: n} {M: n} {P: n} rel @ w N M.
// times z N z.
// times (s N) M Q <-
//    plus N M P,
//    times P M Q.
