// Adding negation to regular expressions
// Figure 5 from the L10 paper, which is contained in the file RegexpNot.l10,
// matches the strings "daa" and "baa" against the regular expression
// ¬(b|c)(a+). Somewhat unexpectedly, this regular expression matches both
// strings: "ba" matches ¬(b|c) "a" matches (a+).

// One way to capture the intended point of the example is to instead match
// against ¬(b|c)(a(a+)), which has the correct behavior: "baa" does not 
// match, whereas "daa" does.

db3' = (token "d" 0, token "a" 1, 
       token "a" 2, token "EOF" 3) 
  @ w1 (seq (neg (alt (tok "b") (tok "c")))
         (seq (tok "a") (some (tok "a")))).

db4' = (token "b" 0, token "a" 1, 
       token "a" 2, token "EOF" 3) 
  @ w1 (seq (neg (alt (tok "b") (tok "c")))
         (seq (tok "a") (some (tok "a")))).

// To get closer to the intended meaning of the example, we can
// add a "wild" expression, which matches any single token, and a "both" 
// expression (r₁&r₂) , which only holds when the string matches both r₁ 
// and r₂. Then we have the ability to express (.&(¬(b|c))(a+)), which 
// emphasizes that ¬(b|c) is only supposed to hold for one character.

wild: regexp.
token _ I -> match wild I (I+1).

both: regexp -> regexp -> regexp.
match RE1 I J,
match RE2 I J ->
   match (both RE1 RE2) I J.

db3'' = (token "d" 0, token "a" 1, 
       token "a" 2, token "EOF" 3) 
  @ w1 (seq (both wild (neg (alt (tok "b") (tok "c"))))
         (some (tok "a"))).

db4'' = (token "b" 0, token "a" 1, 
       token "a" 2, token "EOF" 3) 
  @ w1 (seq (both wild (neg (alt (tok "b") (tok "c"))))
         (some (tok "a"))).

